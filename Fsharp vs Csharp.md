# F# меня испортил, или почему я больше не хочу писать на C#
## Раньше я очень любил C#.
 Это был мой основной язык программирования,
и каждый раз, когда я сравнивал его с другими, я радовался тому, что в свое время случайно выбрал именно его.
Python и Javascript сразу проигрывают динамической типизацией (если к джаваскрипту понятие типизации вообще имеет смысл применять),
Java уступает дженериками, отстутствием ивентов, value-типов, вытекающей из этого карусели с разделением примитивов и объектов
на два лагеря и зеркальными классами-обертками вроде `Integer`, отсутствием пропертей и так далее.

Отдельно отмечу, что я сейчас говорю о самом языке и удобстве написания кода на нем.
Тулинг, обилие библиотек и размер сообщества я сейчас в рассчет не беру, потому что у каждого
из этих языков они развиты достаточно, чтобы промышленная разработка была комфортной в большинстве случаев.

А потом я из любопытства попробовал F#.

## И что в нем такого?
Буду краток, в порядке значимости для меня:
- По умолчанию даже ссылочным типам нельзя присвоить `null`, и компилятор требует инициализацию при объявлении.
- Иммутабельные типы
- Функциональная парадигма оказалась гораздо более строгой и стройной, чем то, что мы сегодня называем ООП.
- Типы-суммы, они же `Discriminated Unions` или размеченные объединения.
- Лаконичность синтаксиса
- SRTP (Статически разрешаемые параметры-типы)
- Computation Expressions
- Выведение типов или type inference

С нуллами все понятно, ничто так не засоряет код проекта, как бесконечные проверки возвращаемых значений вроде `Task<IEnumerable<Employee>>`. Так что сначала давайте обсудим иммутабельность и одновременно лаконичность.
Допустим, имеем следующий POCO класс:
```csharp
public class Employee
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public string Phone { get; set; }
    public bool HasAccessToSomething { get; set; }
    public bool HasAccessToSomethinElse { get; set; }
}
```
Просто, емко, ничего лишнего. Казалось бы, куда лаконичней?
Соответствующий код на F# выглядит так:
```fsharp
type Employee =
{ Id: Guid
  Name: string
  Email: string
  HasAccessToSomething: bool
  HasAccessToSomethingElse: bool }
```
Вот теперь *действительно* нет ничего лишнего. Полезная информация содержится в ключевом слове декларации типа данных,
имени этого типа, именах полей и их типах данных. В примере из C# в каждой строчке есть ненужные `public` и `{ get; set; }`.
Помимо этого, в F# мы получили иммутабельность и защиту от нуллов.
Ну, положим, иммутабельность мы можем и в C# организовать, а `public` с автодополнением написать недолго:

```csharp
public class Employee
{
    public Guid Id { get; private set; }
    public string Name { get; private set; }
    public string Email { get; private set; }
    public string Phone { get; private set; }
    public bool HasAccessToSomething { get; private set; }
    public bool HasAccessToSomethinElse { get; private set; }

    public Employee(Guid id, string name, string email, string phone, bool hasAccessToSmth, bool hasAccessToSmthElse)
    {
        Id = id;
        Name = name;
        Email = email;
        Phone = phone;
        HasAccessToSomething = hasAccessToSmth;
        HasAccessToSomethinElse = hasAccessToSmthElse;
    }
}
```
Готово! Правда, количество кода увеличилось в 3 раза: все поля мы продублировали дважды.
Мало того, когда добавится новое поле, мы можем забыть добавить его в параметры конструктора
и/или забыть присвоить значение внутри конструктора, и *компилятор нам ничего не скажет*.
В F# же при добавлении поля вам нужно добавить новое поле. Все.
Инициализация же выглядит вот так:
```fsharp
let employee =
    { Id = Guid.NewGuid()
      Name = "Peter"
      Email = "peter@gmail.com"
      Phone = "8(800)555-35-35"
      HasAccessToSomething = true
      HasAccessToSomethinElse = false}
```
И если вы забудете одно поле, то код не скомпилируется.
Поскольку тип неизменяемый, единственный способ внести изменение -- создать новый экземпляр.
Но что делать, если мы хотим изменить только одно поле? Все просто:
```fsharp
let employee2 = { employee with Name = "Valera" }
```
Как это сделать в C#? Ну, вы и без меня знаете.
Добавьте вложенные ссылочные поля, и теперь ваш `{ get; private set; }` ничего не гарантирует --
вы можете изменить поля этого поля. Стоит ли упоминать коллекции?

Но так ли нам нужна эта иммутабельность?
Я не случайно добавил два булевых поля про доступ куда-то. В реальных проектах за доступ отвечает
какой-нибудь сервис, и часто он принимает на вход модель и мутирует ее, проставляя где надо `true`.
И вот я в очередном месте программы получаю такую модель, в которой эти булевые свойства выставлены в `false`.
Что это значит? Юзер не имеет доступ или просто модель не прогнали еще через аксесс сервис? А может прогнали,
но там забыли проинициализировать какие-то поля? Я не знаю, я должен проверить и прочитать кучу кода.
Когда же структура неизменяема - я знаю, что там стоят актуальные значения. Но в C# настолько трудно
добиться настоящей иммутабельности, что писать такой код просто нерентабельно, иммутабельность такой
ценой никак не сэкономит время разработки.

Ну, хватит об иммутабельности. Что еще имеем? 

В F# мы так же бесплатно получили:
- Structural Equality
- Structural Comparison

Теперь мы можем использовать такие конструкции:
```fsharp
if employee1 = employee2 then
//...
```
И это действительно будет проверять *равенство* объектов. `Equals` который проверяет равенство по ссылке ***никому даром не нужен***,
у нас уже есть `Object.ReferenceEquals`, спасибо.

Кто-то может сказать, что это никому не нужно, потому что мы не сравниваем объекты в реальных проектах, поэтому `Equals` & `GetHashCode` нам нужны *так* редко, что можно и ручками переопределить. Но я думаю, что причинно-следственная связь тут работает в обратную сторону -- мы не сравниваем объекты, потому что переопределять руками это все и *поддерживать* слишком дорого. Но когда это достается *бесплатно*, применение находится мгновенно: вы можете использовать прямиком ваши модели как ключи в словарях, складывать модели в `HashSet<>` & `SortedSet<>`, сравнивать объекты не по айдишнику (хотя эта опция, разумеется, доступна), а просто сравнивать.

## Discriminated Unions

Думаю, большинство из нас впитали с молоком первого тимлида правило о том, что строить логику на эксепшнах плохо. Например, вместо `try { i = Convert.ToInt32("4"); } catch()...` правильней использовать `int.TryParse`.

Но помимо этого примитивного и до тошноты затертого примера, мы постоянно нарушаем это правило. Юзер ввел невалидные данные? `ValidationException`. Вышли за границы массива? `IndexOutOfRangeException`!

В умных книжках пишут, что исключения нужны для исключительных ситуаций, непредсказуемых, когда что-то пошло совсем не так и нет смысла пытаться продолжать работу. Хороший пример -- `OutOfMemoryException`, `StackOverflowException`, `AccessViolationException` и т.д. Но вылезти за границы массива -- это непредсказуемо? Серьезно? Индексатор на вход принимает `Int32`, множество допустимых значений которого составляет 2 в 32 степени. В большинстве случаев мы работаем с массивами, длина которых не превышает 10000. В редких случаях миллион. То есть значений `Int32`, которые вызовут исключение ***сильно*** больше, чем те, которые отработают корректно, то есть при случайно выбранном инте статистически более вероятно попасть в "исключительную" ситуацию! 
То же самое с валидацией -- юзер ввел кривые данные. **Вот это сюрприз**.

Причина, по которой мы активно злоупотребляем исключениями, проста: нам не хватает мощности системы типов, чтобы адекватно описать сценарий "если все нормально, отдай результат, если нет, верни ошибку". Строгая типизация обязывает нас возвращать один и тот же тип во всех ветках исполнения метода (к счастью), но не хватало еще только в каждый тип добавлять `string ErrorMessage` & `bool IsSuccess`. Поэтому в реалиях C# исключения -- пожалуй, меньшее из зол в данной ситуации.

Опять-таки, можно написать класс
```csharp
public class Result<TResult, TError>
{
    public bool IsOk { get; set; }
    public TResult Result { get; set; }
    public TError Error { get; set; }
}
```
Но тут нам опять придется написать кучу кода, если мы хотим, например, сделать невалидное состояние невозможным. В примитивной реализации можно присвоить и результат, и ошибку, и забыть проинициализировать `IsOk`, так что проблем от этого будет больше, чем пользы.

В F# подобные вещи определяются проще:
```fsharp
type Result<'TResult, 'TError> =
    | Ok of 'TResult
    | Error of 'TError

type ValidationResult<'TInput> =
    | Valid of 'TInput
    | Invalid of string list

let validateAndExecute input =
    match validate input with // проверяем результат исполнения валидационной функции
    | Valid input -> Ok (execute input) // если валидно - возвращаем "Ок" с результатом
    | Invalid of messages -> Error messages // если нет, возвращаем ошибку со списком сообщений
```
Никаких исключений, все лаконично, и главное, что код самодокументирован. Вам не нужно писать в xml doc, что метод кидает какое-то исключение, вам не нужно судорожно оборачивать вызов чужого метода в `try/catch` просто на всякий случай. В такой системе типов исключение -- действительно непредсказуемая, неправильная ситуация. То же самое с индексацией массива:
```fsharp
let doSmth myArray index =
    match Array.tryItem index myArray with
    | Some elem -> Console.WriteLine(elem)
    | None -> ()
```
Здесь используется тип стандартной библиотеки Option:
```fsharp
type Option<'T> =
    | Some of 'T
    | None
```
Каждый раз, когда вы его используете, код сам вам говорит, что отсутствие значения здесь возможно *согласно логике*, а не из-за ошибки программиста. И компилятор кинет ворнинг, если вы забудете обработать все возможные варианты.

## Строгость парадигмы

Чистые функции и expression-based дизайн языка дают нам возможность писать очень стабильный код.
Чистая функция соответствует следующим критериям:
- Единственный результат ее работы - вычисление значения. Она не изменяет ничего во внешнем мире.
- Функция всегда возвращает одно и то же значение для одного и того же аргумента.

Добавьте к этому тотальность (функция может корректно вычислить значение для любого возможного входящего параметра) и вы получите потокобезопасный код, который работает всегда правильно и который легко тестировать.

Expression-based design говорит нам, что все является выражением, у всего есть результат выполнения. Например:
```fsharp
let a = if someCondition then 1 else 2
```
Компилятор заставит нас учесть *все* возможные комбинации, мы не можем остановиться просто на `if`, забыв про `else`.
В C# это обычно выглядит так:
```csharp
int a = 0;
if(someCondition)
{
    a = 1;
}
else
{
    a = 2;
}
```
Здесь легко можно потерять одну ветку в будущем, и `a` останется с дефолтным значением.

Конечно же, на одних чистых функциях далеко не уедешь -- нам нужно I/O, как минимум. Но эти нечистые эффекты можно сильно ограничить до пользовательского ввода и работы с хранилищами данных. Бизнес-логика может быть реализована на чистых функциях, и в этом случае она будет стабильней швейцарских часов.

## Уход от привычного ООП

Стандартный кейс: у вас есть сервис, который зависит от парочки других сервисов и репозитория. Те сервисы, в свою очередь, могут зависеть от других сервисов и от своих репозиториев. Все это скручивается могучим DI фреймворком в тугую колбасу функционала, отдается веб-апи контроллеру при реквесте.

Каждая зависимость нашего сервиса, которых в среднем, допустим, от 2 до 5, как и сам нащ сервис, обычно имеет 3-5 методов, разумеется, большая часть которых совершенно не нужна в каждом конкретном сценарии. Из всего этого раскидистого дерева методов нам нужно в каждом отдельном сценарии обычно 1-2 метода от каждой (?) зависимости, но мы связываем воедино весь блок функционала и создаем кучу объектов. И моки, конечно же. Куда ж без них -- нам нужно же как-то протестировать всю эту красоту. И вот я хочу покрыть тестом метод, но для того, чтобы вызвать этот метод, мне нужен объект этого сервиса. Чтобы его создать, я должен пропихнуть в него моки. Загвоздка в том, чтобы понять, какие именно моки -- какие-то в моем методе вообще не вызываются, они мне не нужны. Какие-то вызываются, но только пара методов из них. Поэтому в каждом тесте я делаю нудный сетап этих моков с возвращаемыми значениями и прочей требухой. Потом я хочу протестировать второй сценарий в *том же методе*. Меня ждет новый сетап. Иной раз в тестах на метод кода больше, чем в самом методе. И да, ***для каждого метода*** я должен лезть в его кишки и смотреть, какие же зависимости мне *действительно* нужны в этот раз.

В функциональной парадигме это работает немного по-другому. Самый крутой пацан здесь -- чистая функция, а не объект. И преимущественно, как вы уже поняли, тут используют иммутабельные значения, а не мутабельные переменные. Кроме того, функции прекрасно композируются, поэтому, в большинстве случаев, нам не нужны *объекты* сервисов вообще. Репозиторий достает из базы то, что тебе нужно? Ну так достань и передай в сервис само значение, а не репозиторий!

Простой сценарий выглядит примерно так:
```fsharp
let getReport queryData =
    queryData
    |> DataRepository.get
    |> Report.build
```
Для тех, кто не знаком с оператором `|>` и каррированием, это равносильно следующему коду:
```fsharp
let gerReport queryData =
    Report.build(DataRepository.get(queryData))
```
На C#:
```csharp
public ReportModel GetReport(QueryData queryData)
{
    // Report здесь -- статический класс. В него компилируются F# модули
    return Report.Build(DataRepository.Get(queryData));
}
```

А поскольку функции прекрасно композируются, можно написать вообще вот так:
```fsharp
let getReport = DataRepository.get >> Report.build
```

Заметьте, тестировать `Report.build` теперь проще некуда. Вам моки не нужны вообще. Более того, есть фреймворк `FsCheck`, который генерирует сотни входных параметров и запускает с ними ваш метод, и показывает данные, на которых метод сломался. Все, что вам нужно сделать -- 1 раз написать генератор для вашего типа. Чем это лучше написания моков? Генератор универсален, он подходит для **всех** будущих тестов, и вам не нужно знать имплементацию чего бы то ни было, для того, чтобы его написать.

## Statically Resolved Type Parameters (SRTP)

Тут лучше показать, чем рассказать.
```fsharp
let inline square
     (x: ^a when ^a: (static member (*): ^a -> ^a -> ^a)) = x * x
```
Эта функция будет работать для *любого* типа, у которого определен оператор умножения с соответствующей сигнатурой. Разумеется, это распространимо и на обычные статические методы, не только операторы. И не только на статические!
```fsharp
let inline GetBodyAsync x = (^a: (member GetBodyAsync: unit -> ^b) x)

open System.Threading.Tasks
type A() =
    member this.GetBodyAsync() = Task.FromResult 1

type B() =
    member this.GetBodyAsync() = async { return 2 }

A() |> GetBodyAsync |> fun x -> x.Result // 1
B() |> GetBodyAsync |> Async.RunSynchronously // 2
```
Нам не нужно определять интерфейс, писать врапперы для чужих классов, имплементить интерфейс, единственное условие -- чтобы у типа был метод с подходящей сигнатурой! Я не знаю способа сделать так в C#.

## Computation Expressions

Мы рассматривали пример с типом `Result`. Допустим, мы хотим выполнить каскад операций, каждая из которых нам возвращает этот самый `Result`. И если хоть одно звено в этой цепи вернет ошибку, мы хотим прекратить выполнение и вернуть ошибку сразу.
Вместо того, чтобы писать бесконечные
```fsharp
let res arg =
    match doJob arg with
    | Error e -> Error e
    | Ok r ->
        match doJob2 r with
        | Error e -> Error e
        | Ok r -> ...
```
Мы можем один раз написать
```fsharp
type ResultBuilder() =
    member __.Bind(x, f) =
        match x with
        | Error e -> Error e
        | Ok x -> f x
    member __.Return x = Ok x
    member __.ReturnFrom x = x

let result = ResultBuilder()
```
И использовать это так:
```fsharp
let res arg =
    result {
        let! r = doJob arg
        let! r2 = doJob2 r
        let! r3 = doJob3 r2
        return r3
    }
```
Теперь на каждой строчке с `let!` в случае `Error e` мы вернем ошибку. Если же все все будет хорошо, в конце вернем `Ok r3`.
И вы можете делать такие штуки *для чего угодно*, включая даже использование кастомных операций с кастомными названиями. Богатый простор для построения DSL.

## Итог

Получив все эти мощные инструменты и привыкнув к ним, начинаешь решать задачи быстрее и изящней. Большая часть кода, 1 раз написанная и 1 раз протестированная работает **всегда**. Писать же снова на C# для меня значит отказаться от них и потерять в продуктивности. Я словно возвращаюсь в прошлый век -- вот я бегал в удобных кроссовках, а теперь в лаптях. Лучше, чем ничего, но хуже, чем что-то.
Я бы сказал, что главная проблема F# -- это то, что тяжело его "продать" сишарпистам.
Но если вы все же решитесь изучить F# -- втянуться будет легко. 

И тесты будет писать приятно, и от них **действительно** будет много пользы. Property-based тесты (те, что я описывал в примере с FsCheck)
мне несколько раз показали ошибки *проектирования*, которые силами QA искались бы *очень* долго. Юнит-тесты же в основном показывали мне,
что я забыл что-то обновить в конфигурации тестов. И да, время от времени, показывали, что я что-то где-то упустил в коде.
В F# с этим справляется компилятор. Бесплатно.
